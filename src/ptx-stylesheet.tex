%:strip
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Part of the ptx2pdf macro package for formatting USFM text
% copyright (c) 2007-2020 by SIL International
% written by Jonathan Kew
%
% Permission is hereby granted, free of charge, to any person obtaining  
% a copy of this software and associated documentation files (the  
% "Software"), to deal in the Software without restriction, including  
% without limitation the rights to use, copy, modify, merge, publish,  
% distribute, sublicense, and/or sell copies of the Software, and to  
% permit persons to whom the Software is furnished to do so, subject to  
% the following conditions:
%
% The above copyright notice and this permission notice shall be  
% included in all copies or substantial portions of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  
% EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  
% NONINFRINGEMENT. IN NO EVENT SHALL SIL INTERNATIONAL BE LIABLE FOR  
% ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF  
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  
% WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
%
% Except as contained in this notice, the name of SIL International  
% shall not be used in advertising or otherwise to promote the sale,  
% use or other dealings in this Software without prior written  
% authorization from SIL International.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Macros to read Paratext stylesheets and define TeX control sequences
%% for all markers present in the file

%
% Macros to process each marker used in a Paratext stylesheet,
% either ignoring it or saving the parameter as appropriate
%
%+csty_definition_setup
\def\h@phen{-} % for matching
\def\tru@{true}% for matching
\def\ds@ffix{} % diglot suffix (L/R)
\def\m@rker{} % The currently being defined \Marker
\let\prev@rsemode\empty
\def\remember@xists#1{\x@\xdef\csname m@rkerexists-#1\ds@ffix\endcsname{t}}
\def\should@xist#1{\ifcsname m@rkerexists-#1\endcsname\else
  \trace{sC}{Remembering that #1 exists as a marker}%
  \remember@xists{#1}%
  \setpp@name{#1}\x@\global\x@\let\csname \pp@name\endcsname\relax%Invalidate old cache
\fi
}

% Remember the name of the marker currently being defined
\def \Marker         #1\relax{\m@kedigitsletters%
  \xdef\m@rker{\scantokens{#1\noexpand}}%
  \m@kedigitsother\remember@xists{\m@rker}% store name of marker currently being defined
  \ifx\c@tprefix\empty\else
    \remember@xists{\c@tprefix\m@rker}%
  \fi
  \expandafter\let\csname font<\m@rker>\endcsname\relax}
  %\expandafter\let\csname extrafont<#1>\endcsname\relax}
%-csty_definition_setup

%+csty_definitions
% Make sure we list everything that can occur in a .sty file. If a .sty file contains a
% missing sfm marker, then processing for that and all subsequent stylesheets will stop
% at that point.
% Ignore stylesheet markers that do not affect formatting 
\def \Name           #1\relax{}
\def \Description    #1\relax{}
\def \OccursUnder    #1\relax{}
\let \Occursunder\OccursUnder
\def \Rank           #1\relax{}
\def \Underline      #1\relax{}
\let \underline\Underline
\def \NotRepeatable  #1\relax{}
\let \Notrepeatable\NotRepeatable
\def \Color          #1\relax{\defp@ram{color}{#1}}
\def \Background     #1\relax{\defp@ram{background}{#1}}
\let \color\Color
\def \ColorName      #1\relax{}

% For each property that affects formatting, define a macro to store the value
% of this field, these will be accessed via getp@ram.
% Constructs a macro name \<marker>:<parameter> to hold the value
\def \Endmarker      #1\relax{\defp@ram{endmarker}{#1}} % endmarker is not currently checked except for milestones
\def \TextType       #1\relax{\lowercase{\defp@ram{type}{#1}}}
\let \Texttype\TextType
\def \TextProperties #1\relax{\lowercase{\defp@ram{properties}{#1}}}
\let \Textproperties\TextProperties
\def \FontSize       #1\relax{\defp@ram{fontsize}{#1}}
\let \Fontsize\FontSize
\def \FontScale      #1\relax{\defp@ram{fontscale}{#1}}
\let \Fontscale\FontScale
\def \FontFactor     #1\relax{\defp@ram{fontfactor}{#1}}
\def \FontName       #1\relax{\defp@ram{fontname}{#1}}
\let \Fontname\FontName
\def \FirstLineIndent #1\relax{\defp@ram{firstindent}{#1}}
\let \Firstlineindent\FirstLineIndent
\def \LeftMargin     #1\relax{\defp@ram{leftmargin}{#1}}
\let \Leftmargin\LeftMargin
\def \RightMargin    #1\relax{\defp@ram{rightmargin}{#1}}
\let \Rightmargin\RightMargin
\def \Italic         #1\relax{\defbinp@ram{italic}{#1}}
\def \Bold           #1\relax{\defbinp@ram{bold}{#1}}
\def \Superscript    #1\relax{\condp@ram{#1}{\defp@ram{raise}{\SuperscriptRaise}\defp@ram{fontfactor}{\SuperscriptFactor}}{\defp@ram{raise}{0pt}\defp@ram{fontfactor}{1}}}
\def \Raise          #1\relax{\defp@ram{raise}{#1}}
\def \Regular        {\defp@ram{regular}{true}\defp@ram{italic}{false}\defp@ram{bold}{false}\defp@ram{superscript}{false}\defp@ram{smallcaps}{false}}
\let \superscript\Superscript
\def \SpaceBefore    #1\relax{\defp@ram{spacebefore}{#1}}
\let \Spacebefore\SpaceBefore
\def \SpaceAfter     #1\relax{\defp@ram{spaceafter}{#1}}
\let \Spaceafter\SpaceAfter
\def \Justification  #1\relax{\lowercase{\defp@ram{justification}{#1}}}
\def \CallerStyle    #1\relax{\defp@ram{callerstyle}{#1}} % ptx2pdf extension
\def \CallerRaise    #1\relax{\defp@ram{callerraise}{#1}}
\def \NoteCallerStyle    #1\relax{\defp@ram{notecallerstyle}{#1}} % ptx2pdf extension
\def \NoteCallerRaise    #1\relax{\defp@ram{notecallerraise}{#1}}
\def \NoteBlendInto      #1\relax{\defp@ram{notebase}{#1}}
\def \TEStyleName    #1\relax{} % Translation Editor extension
\def \SmallCaps      #1\relax{\defbinp@ram{smallcaps}{#1}}
\let \Smallcaps\SmallCaps
\def \BaseLine       #1\relax{\defp@ram{baseline}{#1}}
\def \LineSpacing    #1\relax{\defp@ram{baseline}{#1\onel@neunit}}
\def \ztexFontFeatures  #1\relax{\defp@ram{fontfeatures}{#1}}
\def \ztexFontGrSpace   #1\relax{\defp@ram{fontgrspace}{#1}}

% Make a TeX macro based on the StyleType
\def \StyleType      #1\relax{\lowercase{\def\styl@type{#1}}\m@kestyle}     %(1)
\let \Styletype=\StyleType
% New extras that PTX supports
\def \XMLTag         #1\relax{}
\def \Encoding       #1\relax{}
\def \Rank           #1\relax{}
\def \TEStyleName    #1\relax{}
\def \NotRepeatble   #1\relax{}
\def \Attributes     #1\relax{}
%-csty_definitions

%+csty_defparam
%:
% \defp@ram: store the value of a parameter from the .sty file
% p | description
% --|------
% #1|name of parameter to store
% #2|value
% --|------
% Constructs a macro name \_<marker>_:_<parameter>_ to hold the value.
% `csname` is required here in order to build a macro name containing a colon and possibly a number.
%

\def\defp@ram#1#2{\x@\def\csname\c@tprefix\m@rker\ds@ffix:#1\endcsname{#2}\trace{s}{\c@tprefix\m@rker\ds@ffix:#1 -> #2}}
\def\condp@ram#1#2#3{\edef\t@mp{#1}\ifx\t@mp\h@phen\relax\def\t@mp{#3}\else\def\t@mp{#2}\fi\t@mp}
\def\defbinp@ram#1#2{\edef\t@mp{#2}\ifx\t@mp\h@phen\defp@ram{#1}{false}\else\defp@ram{#1}{true}\fi}
\def\setp@ram#1#2#3{
  \x@\xdef\csname\c@tprefix#2\ds@ffix:#1\endcsname{#3}\trace{s}{\c@tprefix#2\ds@ffix:#1 -> #3}
  \should@xist{#2}%Ensure that the marker is in the exists list
} % expand now, not later 
%-csty_defparam

%+csty_getparam
%:
% \getp@aram: fetch the value of a style parameter into \p@ram
% --|------
% #1|name of parameter to fetch
% #2|name of marker
% --|------
% Sets temporary macro \p@ram to the value
% The macro was once just diglot aware, allowing all parameters to have L Left/Right variant or use
% default. (e.g when asked for paramter for v, check for vL|vR, default to v). Now it (potentially) needs to 
% take into account: diglot, categories and milestones.
% Rather than attempt to code \ifs for all possible 8 options, it now builds a comma-separated list of them, 
% and finds the first match. This results in cleaner code.

\def\s@tpossParams#1{\trace{s}{setpossParam #1 (\styst@kskip/\styst@kfirst/\styst@k)}%
  \ifdiglot
     \edef\p@ssParams{#1\c@rrdstat,#1}%
  \else
     \edef\p@ssParams{#1}%
  \fi
  \edef\tmp{#1}\ifx\tmp\styst@k\else
    \ifx\styst@k\empty\else
      \ifx\tmp\styst@kfirst\else
         \edef\p@ssParams{#1+\styst@kfirst,\p@ssParams}%
      \fi
      \ifx\styst@k\styst@kfirst\else%styst@k may be the same as styst@kfirst
         \edef\p@ssParams{#1+\styst@k,\p@ssParams}%
      \fi
    \fi
  \fi
  \trace{s}{1. Checking \p@ssParams}%
   %\ifx\mspr@fix\empty\else
     %If we expand our prefix list for special styling of milestone+marker, then:
     %\exp@ndmspr@fix{\let\@ut=\empty \let\d@=\cspr@pend\x@\cstackdown \p@ssParams,\E \edef\p@ssParams{\@ut,\p@ssParams}}%
   %\fi
   %\trace{s}{2. Checking \p@ssParams}%
  \ifx\c@tprefix\empty\else
    \edef\@lso{\c@tprefix}%
    \let\@ut=\empty \let\d@=\cspr@pend\x@\cstackdown \p@ssParams,\E \edef\p@ssParams{\@ut,\p@ssParams}%
  \fi
  \trace{s}{2. Checking \p@ssParams}%
  \let\@ut\empty
  \let\tmpd@=\d@
  \let\d@=\cscheck@xist\x@\cstackdown \p@ssParams,\E
  \let\d@=\tmpd@
  \global\let\p@ssParams=\@ut
  \trace{s}{3. Shrunk list:\p@ssParams}%
}
\def\kill@cache #1\E{%Remove listed item
   \x@\global\x@\let\csname #1\endcsname\relax}

\def\p@ssParamCached{}

\def\kill@PossParamCache{\ifx\p@ssParamCached\empty\else% kill cached possParam-\m@rker values  
    \let\d@=\kill@cache
    \x@\cstackdown\p@ssParamCached,\E
    \global\let\p@ssParamCached\empty
    \trace{sC}{Emptied p@ssParamCached}%
  \fi
}

\def\setpp@name#1{%
  \edef\tmppar@mtwo{#1}\ifx\styst@k\tmppar@mtwo
   \xdef\pp@name{pPrms-\c@tprefix#1/--}%
  \else
   \xdef\pp@name{pPrms-\c@tprefix#1/\styst@k}%
  \fi
}

\def\getp@ram#1#2{\trace{s}{getp@ram #2:#1 (\mcstack)}%
 \iftrue
   \let\p@ram\relax
   \def\gp@test{#1}%
   \ifx\gp@test\empty\message{Eh? getp@ram called for #2 and empty parameter}\else 
     \setpp@name{#2\c@rrdstat}%
     \x@\let\x@\g@tp@tmp\csname \pp@name\endcsname
     \ifx\g@tp@tmp\relax
       \s@tpossParams{#2}\x@\global\x@\let\csname \pp@name\endcsname\p@ssParams
       \ifx\p@ssParamCached\empty
         \xdef\p@ssParamCached{\pp@name}%
       \else
         \xdef\p@ssParamCached{\p@ssParamCached,\pp@name}%
       \fi
       \trace{sC}{\pp@name\space defined (\p@ssParamCached) as \p@ssParams}%
     \else
       \global\let\p@ssParams\g@tp@tmp
       \trace{sC}{\pp@name\space exists: \p@ssParams}%
     \fi
     {%protect outer version of \d@, etc.
     %\tracingassigns=1
     %\tracingmacros=1
    % Final version of the list might be cat:inl|ms:qt|pR,cat:inl|ms:qt|p,cat:inl|pR,cat:inl|p,ms:qt|pR,ms:qt|p,pR,p
     \gettop@aram{#1}%
     \global\let\p@@r@m=\p@ram % Need to return outside the brackets
     %\tracingassigns=0
     %\tracingmacros=0
     }%
     \let\p@ram=\p@@r@m
   \fi
 \else %Old, working, but ignorant of milestones
   \ifdiglot
    \getp@r@m{#1}{\c@tprefix#2\c@rrdstat}%
    \ifx\p@ram\relax
      \ifx\c@tprefix\empty\else\getp@r@m{#1}{\c@tprefix#2}\fi%
    \else
      \trace{sc}{Category specific(\c@tprefix#2\c@rrdstat):#1 found}%
      \trace{Ds}{...side-specfic -> \p@ram}%
    \fi
    \ifx\p@ram\relax
      \getp@r@m{#1}{#2}\trace{Ds}{...default -> \p@ram}%
    %\else
      %\trace{Ds}{...side-specfic -> \p@ram}%
    \fi
   \else\getp@r@m{#1}{\c@tprefix#2}%
    \ifx\p@ram\relax
      \ifx\c@tprefix\empty\else
	\getp@r@m{#1}{#2}%
      \fi
    \else
      \ifx\c@tprefix\empty\else\trace{sc}{Milestone/Category specific(\c@tprefix#2):#1 found}\fi%
    \fi
   \fi
 \fi
  \trace{s}{\space\space (\c@tprefix)(\mspr@fix)#2\ifdiglot(\c@rrdstat)\fi :#1 is \p@ram}%
}
\def\gettop@aram#1{%Check list of acceptable parameters and return the first one found.
   \edef\p@ramcheck{#1}%
   \ifx\p@ramcheck\empty\else
     \trace{s}{Checking for #1 in \p@ssParams}%
     \let\d@=\stackg@tp@ram
     \x@\cstackdown \p@ssParams,\E
   \fi
}

\def\stackg@tp@ram#1\E{\getp@r@m{\p@ramcheck}{#1}\ifx\p@ram\relax\else\let\d@=\cstackrelax\fi}
\def\getp@r@m#1#2{\x@\let\x@\p@ram\csname#2:#1\endcsname \ifx\p@ram\relax\else\trace{s}{#2:#1 found: \p@ram}\fi}
\def\cspr@pend#1\E{\ifx\@ut\empty\xdef\@ut{\@lso#1}\else\xdef\@ut{\@ut,\@lso#1}\fi}
\def\cs@lsolist#1\E{\trace{s}{expanding #1->\@lso#1,#1}\ifx\@ut\empty\xdef\@ut{\@lso#1,#1}\else\xdef\@ut{\@ut,\@lso#1,#1}\fi}
\def\cscheck@xist#1\E{\ifcsname m@rkerexists-#1\endcsname\ifx\@ut\empty\xdef\@ut{#1}\else\xdef\@ut{\@ut,#1}\fi\fi}

%\def\cs@lsolist#1\E{\trace{s}{expanding #1->\@lso#1,#1}\@lso#1,#1}
%-csty_getparam

%+csty_getmcparam
%Main utility function for font parameters, stacking-styles aware
\def\getmcp@ram#1{\trace{s}{getmcp #1}\let\r@s=\relax
  \def\d@##1+##2\E{\edef\tmp{##2}\ifx\tmp\empty\else\csname d@code-##1\endcsname\if##1\ss@Sbar\global\let\r@s\relax\else\if##1\ss@Note\global\let\r@s\relax\fi\fi
    \getp@ram{#1}{\tmp}\ifx\p@ram\relax\else\global\let\r@s\p@ram\fi\fi}%
  \mcup\global\let\p@ram\r@s\traceNum{s}{param #1 for \mcstack\space is \p@ram}}    %(1)
\def\getmcp@ramR#1{\trace{s}{getmcpR #1}\let\r@s\relax
  \def\d@##1+##2\E{\edef\tmp{##2}\ifx\tmp\empty\else\csname d@code-##1\endcsname\if##1\ss@Sbar\global\let\r@s\relax\else\if##1\ss@Note\global\let\r@s\relax\fi\fi
    \getp@ram{regular}{\tmp}\ifx\p@ram\relax\getp@ram{#1}{\tmp}\ifx\p@ram\relax\else\global\let\r@s\p@ram\fi
                           \else\global\let\r@s\relax\fi\fi}%
  \mcup\global\let\p@ram\r@s\traceNum{s}{paramR #1 for \mcstack\space is \p@ram}}
 
\def\getFp@ram#1#2{%
  \let\p@ram\relax
  \def\d@##1+##2\E{\edef\tmp{##2}\csname d@code-##1\endcsname\edef\tmpa{#2}\ifx\tmp\tmpa\getmcp@ram{#1}\else\getp@ram{#1}{#2}\fi}%
  \mctop}
\def\getFp@ramR#1#2{%
  \def\d@##1+##2\E{\edef\tmp{##2}\csname d@code-##1\endcsname\edef\tmpa{#2}\ifx\tmp\tmpa\getmcp@ramR{#1}\else\getp@ram{#1}{#2}\fi}%
  \mctop}
%-csty_getmcparam

%+csty_getmcfontsize
\def\getmcfonts@ze{\trace{s}{getmcfonts@ze}\getp@ram{fontsize}{p}\ifx\p@ram\relax\edef\ps@ze{12}\else\edef\ps@ze{\p@ram}\fi
  \def\d@##1+##2\E{\edef\tmp{##2}\ifx\tmp\empty\else
      \csname d@code-##1\endcsname
      \let\tmpstylen@me\tmp
      \dimen0=\c@rrfontsize pt 
      \ifnum\if##1\ss@Para 1\else\if##1\ss@Note 1\else0\fi\fi =1
        \getp@ram{fontsize}{\tmpstylen@me}\dimen0=\ifx\p@ram\relax 12\else\p@ram\fi pt%
      \else\getp@ram{fontscale}{\tmpstylen@me}\edef\sc@le{\p@ram}%                            %(1)
        \ifx\p@ram\relax\edef\sc@le{1}\getp@ram{fontsize}{\tmpstylen@me}%
          \ifnum\ifx\p@ram\relax 1\else\ifx\p@ram\ps@ze 1\else 0\fi\fi =1
            \dimen0=\sc@le\dimen0\else\dimen0=\p@ram pt\fi
        \else\dimen0=\sc@le\dimen0                                                  %(2)
    \fi\fi\xdef\c@rrfontsize{\strip@pt{\dimen0}}\fi\trace{s}{\space working c@rrfontsize from ##2 is \c@rrfontsize}}%
  \mcup\trace{s}{set c@rrfontsize for \mcstack\space is \c@rrfontsize}}             %(3)
%-csty_getmcfontsize

%+csty_makestyle
\def\m@kestyle{{\uccode`\|=`\\\uppercase{\message{|\m@rker}}}
 \x@\let\csname font<\m@rker>\endcsname=\relax 
 \ifx\styl@type\P@ra \x@\defp@rstyle\x@{\m@rker}
 \else\ifx\styl@type\Ch@r \x@\defch@rstyle\x@{\m@rker}
 \else\ifx\styl@type\N@te \x@\defn@testyle\x@{\m@rker}
 \else\ifx\styl@type\MSt@ne \x@\defmst@nestyle\m@rker\E
 \else \message{unknown style type '\styl@type'}
 \fi\fi\fi\fi}
\def\P@ra{paragraph}
\def\Ch@r{character}
\def\N@te{note}
\def\MSt@ne{milestone}

%:
% \def*style: define a USFM marker as a paragraph, character or note style marker
% which will expand to \p@rstyle, \ch@rstyle or \n@testyle, with the marker name
% as its parameter
%
% \csname...\endcsname is used because the marker may contain numbers as well as letters
%
\def\defp@rstyle#1{\x@\def\csname#1\endcsname{\p@rstyle{#1}}}
\edef\pl@scatcode{\the\catcode`+}
\catcode`+=11
\def\defch@rstyle#1{\x@\def\csname#1\endcsname{\ch@rstyle{#1}}\x@\def\csname +#1\endcsname{\ch@rstylepls{#1}}}
\catcode`+=\pl@scatcode
\def\defn@testyle#1{\x@\def\csname#1\endcsname{\n@testyle{#1}}\m@ken@tecl@ss{#1}}
%Make a milestone marker if there isn't a character style with the same prefix
\def\defmst@nestyle#1\E{\x@\let\x@\tmp\csname #1\endcsname
  \ifx\tmp\relax
    \getp@r@m{endmarker}{\m@rker}%
    \ifx\p@ram\relax
      \x@\def\csname#1\endcsname{\def\milestoneOp{}\mst@nestyle{#1}}%
    \else
      \x@\def\csname#1\endcsname{\def\milestoneOp{s}\mst@nestyle{#1}}%
      \x@\def\csname\p@ram\endcsname{\def\milestoneOp{e}\mst@nestyle{#1}}%
    \fi
  \fi} 
%-csty_makestyle

%+csty_sethook
% Allow "hooking" custom TeX code at the beginning or ending of specific styles.
% e.g. `\sethook{start}{s1}{-}` put a hyphen at the start of every section heading
\def\sethook#1#2#3{\x@\def\csname #1-#2\endcsname{#3}}
\def\setbookhook#1#2#3{\x@\def\csname book#1-#2\endcsname{#3}}
%-csty_sethook

%+csty_testpublishability
% All types of marker use this to check for the "nonpublishable" property
\def\t@stpublishability#1{\n@npublishablefalse % check if "nonpublishable" occurred in the marker's \Properties
 \getp@ram{properties}{#1}%
 \x@\t@stnonpub\p@ram nonpublishable!}
\def\t@stnonpub #1nonpublishable#2!{%
 \def\t@st{#2}\ifx\t@st\empty\else\n@npublishabletrue\fi}
\newif\ifn@npublishable
%-csty_testpublishability

% Patch in special handling for \c and \v.
%+csty_defv
\newif\ifhangingverse

\lowercase{
 % `~` is set by lowercase to a space for delimiting \ch@rstylepls
 \def\@ddcvhooks{
  % called after \c and \v have been processed in stylesheet at beginning of typesetting file
  \let\@V=\v% remember \v defn for (A) below
  % Define a macro to read an actual space delimited verse number, and then check if the next token is \vp
  \def\@v@ ##1 {\gdef\v@rse{##1}\ifdiglot\x@\global\x@\let\csname @v@rse\g@tdstat\endcsname\v@rse\fi\global\let\print@bleVerse\v@rse\futurelet\mayb@vp\@V@}%
  % If the next token IS vp, then call relevant code to interpret before dropping 
  \def\@V@{%
   \let\nxt\@@V@@
   \ifx\mayb@vp\vp\let\nxt\@@VP@@\fi\nxt}%
  \def\@@VP@@\vp ##1\vp*{\xdef\print@bleVerse{##1}\@@V@@}
  \def\@@V@@{%
   \the\prev@rsehooks
   \x@\spl@tverses\print@bleVerse--\relax % split verse in a verse bridge (e.g. 3-4) into \v@rsefrom, \v@rseto
   %\ if not cancelling first verse, output verse number
   \ifc@ncelfirstverse\else
    \ifrotate
     \setbox0=\hbox{\ch@rstylepls{v}~\printv@rse\ch@rstylepls{v}*}\dimen0=\wd0%
     \dimen1=\ht0\dimen2=0.5\dimen0\advance\dimen2 -0.5\ht0%
     \setbox0=\hbox{~\lower\dimen2\hbox to \dimen1{\kern\ht0\special{x:gsave}\special{x:rotate 90}%
      \box0\special{x:grestore}\hss}}\ht0=0pt\dp0=0pt\@V\box0\@V*%
    \else
     \ch@rstylepls{v}~\printv@rse\ch@rstylepls{v}*% (A) output verse number using saved style. ~ will lowercase to a space
    \fi
    \kern\AfterVerseSpaceFactor\FontSizeUnit
   \fi
   \egroup
   \m@rkverse % generate a milestone for running headers
   % run the hooks for picture insertion, paragraph adjustments, etc.
   % these hooks were added via \addtoversehooks
   \the\v@rsehooks
   % remember current chapter:verse, not currently used. Could potentially be used
   % to insert chapter:verse in footnotes.
   \gdef\reference{\ch@pter:\v@rse}%
   \ifhangingverse
     \trace{hv}{Hanging verse \reference}%
     \hangingversefalse
   \fi
   \nobreak\hskip0.5sp % let \x detect that there's "space" (or maybe drop-chapter) here
  }
  \let\C@T\cat %Preserve \cat definition from stylesheet in case that's ever useful, and then restore it to correct version
  \let\cat\c@t
%-csty_defv
  % define handling for usfm \v marker
%+csty_verse
  \def\v{%
   \ifvmode\xdef\prev@rsemode{\m@rker}\else
     \ifhangingverse 
       \trace{hv}{Horiz Mode:cancel hangingverse}%
       \hangingversefalse % Cancel
     \fi
   \global\let\prev@rsemode\empty\fi
   \leavevmode % ensure we are in horizontal mode to build paragraph
   % set c@ncelfirstversetrue if we are immediately following a drop cap chapter number
   % and the user has requested omission of the first verse number in a chapter
   \c@ncelfirstversefalse
   \dimen0=\lastkern
   \ifnum\spacefactor=\n@wchaptersf \kern0sp % override \hangversenumber here
    \ifOmitVerseNumberOne \c@ncelfirstversetrue \fi \fi
   % -1sp indicates that a hanging verse number has been requested here. But that does not seem as reliable as \ifhangingverse
   % When this happens we make ll@p use llap to right justify the verse number at the current position.
   % Otherwise make ll@p do nothing.
   \ifdim\lastkern=-1sp \hangingversetrue\fi
   \ifhangingverse \let\ll@p=\llap
   \else \let\ll@p=\relax
   \fi % hanging verse number?
   %\trace{hv}{lastkern \the\dimen0}%
   \ll@p\bgroup\m@kedigitsother\@v@}%
  % remember chapter macro for later
%-csty_verse
%+csty_chapdef
  \let\@C=\c
  % Define a macro to process space delimited chapter number
  % ## is necessary because this is a nested macro definition
  \def\@c@ ##1 {\ifsk@pping \egroup \fi % if we were skipping, stop it
  \gdef\ch@pter{##1}% remember chapter number
  \gdef\ch@ptert@xt{##1}% the chapter number we will actually output
  \gdef\v@rse{}% clear verse number
  \ifdiglot
    \trace{c}{Saving chapter number '\ch@pter' for side: \c@rrdstat}%
    \x@\global\x@\let\csname @ch@pter\g@tdstat\endcsname\ch@pter
    \x@\global\x@\let\csname @ch@ptert@xt\g@tdstat\endcsname\ch@ptert@xt
    \x@\global\x@\let\csname @v@rse\g@tdstat\endcsname\v@rse
  \fi
  \uppercase{\xdef\c@rref{\id@@@\ifdiglot\c@rrdstat\fi\ch@pter.0}}%
  \global\let\print@bleVerse=\v@rse
  \m@kedigitsletters
   % If omitting chapter number, skip this. 
   % We would have to set \OmitChapterNumbertrue on a book by book basis
   % in the configuration file in order to omit chapter numbers for single chapter books.
  \ifOmitChapterNumber
    \trace{c}{Chapter numbers ommitted}%
  \else
    % if chapter label not present, set \ch@ptertrue to cause chapter number to be printed
    % at start of first text paragraph.
    \x@\global\x@\let\x@\ch@pl@bel\csname ch@plabel\g@tdstat\endcsname% global as p@rstyle{cl} may end a group.
    \ifx\ch@pl@bel\empty \global\ch@ptertrue 
      \trace{c}{No chapter label in use : \ch@pter}%
    \else % if \cl present, output chapter label here
      \trace{c}{Chapter label in use: \ch@pl@bel \ch@pter}%
      \p@rstyle{cl}\ch@pl@bel\ \ch@pter
      \pdfb@@kmark \pdfch@ptermark
    \fi
  \fi}
  %
  \def\c{\m@kedigitsother\@c@}
  \def\cp ##1 {\gdef\ch@ptert@xt{##1}}
%-csty_chapdef
  % set default value for drop cap chapter number size if not already set
%+csty_dropchap
  \ifdim\dropnumbersize=0pt
    \calcdr@psize
  \fi
  \def\m@rker{c}\defp@ram{fontsize}{\dr@psize}%
  \ifdiglot \resetdropc@p\fi%Can't do this here since things get lowercased
 }
%-csty_dropchap

}

\def\calcdr@psize{%
  \ifdiglot 
    \trace{d}{Calculating drop: \c@rrdstat}%
    \should@xist{c\c@rrdstat}%
    \s@tbaseline{p\c@rrdstat}%
  \else
    \s@tbaseline{p}%
  \fi
    \getp@ram{fontsize}{c}\dropnumbersize=0\p@ram\FontSizeUnit \relax % C in following
	% if font size specified for chapter number stylesheet is less than 2*paragraph font size ...
    %\ifdim\dropnumbersize<\dimen255
      \edef\@seglyphmetrics{\the\XeTeXuseglyphmetrics}%
      \s@tfont{p}%workaround for Lotus Elam Bold issue - ensure the \p font is loaded first
      \XeTeXuseglyphmetrics=0\relax\setbox1=\hbox{0}% get font metrics          %(1)
      \XeTeXuseglyphmetrics=3\s@tfont{c}\relax\setbox0=\hbox{0123456789}% set a box at the size specified by the \c marker
      \XeTeXuseglyphmetrics=\@seglyphmetrics% \tracingcommands=0\MSG{useglyphmetrics=\the\XeTeXuseglyphmetrics}
	  %clear font<c> so that it will get rebuilt on next setfont for \c (after we have figured out real size)
      \x@\let\csname font<c>\endcsname=\relax 
	  % Calculate drop cap height = base line height + (lower case) x height
      % get x height (appendix F) 5 is x-height of font X=x + baselineskip
      \s@tfont{p}\dimen0=\fontdimen5\font\advance\dimen0\baselineskip           %(2)
      \dimen1=\dimen0 \multiply\dimen1 by 128 \divide\dimen1 by \dropnumbersize % X/C * 128
      \dimen2=\ht1 \advance\dimen2 by \dp1 \advance\dimen2 by \baselineskip % total height available: T
      \dimen3=128\dimen0 \divide\dimen3 by \dimen2 \multiply\dimen3 by \dropnumbersize \divide\dimen3 by 128 % CX/T
      \dimen4=\dp1 \multiply\dimen4 by \dimen1 \divide\dimen4 by 128 % scaled available
      \trace{h}{dimen0=\the\dimen0, dimen1=\the\dimen1, dimen2=\the\dimen2, dimen3=\the\dimen3,
                dimen4=\the\dimen4, dp0=\the\dp0, ht0=\the\ht0, dp1=\the\dp1, ht1=\the\ht1,
                FontSizeUnit=\the\FontSizeUnit, dropnumbersize=\the\dropnumbersize}%
      \ifdim\dimen3<\ht0 \dimen2=\dimen3\else\ifdim\dimen4<\dp0\dimen2=\dimen3\else\dimen2\ht0\fi\fi % min(CX/T, ht(0))
      \trace{h}{starting height=\the\dimen2}%
      % The following calculations are scaled by 128 in order to get better accuracy even though calculations are integer values
	  % divide desired height by current height
      \multiply\dimen0 by 128                                                   %(3)
      \divide\dimen0 by \dimen2
	  % multiply by original size from \c marker in stylesheet
      \trace{h}{font x-height \x@\the\fontdimen5\font, ht of digits \the\ht0, dp of digits \the\dp0, baselineskip \the\baselineskip, for dropcaps \the\dimen0\space multiply by \the\dropnumbersize}%
      \dimen3=\dimen0 % depth scale factor * 128
      \multiply\dimen0 by \dropnumbersize
      \dropnumbersize=\dimen0
      % divide by the \FontSizeUnit to get value for fontsize param of marker \c
      \divide\dropnumbersize by \FontSizeUnit
      \multiply\dropnumbersize by 512 % (2^16 / 128)
      \multiply\dimen3 by \dp0  % new depth
      \divide\dimen3 by 128
      \trace{h}{dropnumbersize=\the\dropnumbersize, dimen1=\the\dimen1, dimen3=\the\dimen3}%
      \ifdim\dimen3>\dp1 % would overflow downwards. Need to shift              %(4)
        \advance\dimen3 by -\dp1% \divide\dropnumberraise by 2
        \setp@ram{raise}{c\ifdiglot\c@rrdstat\fi}{\the\dimen3}%
      \fi
      \trace{h}{dropnumbersize = \the\dropnumbersize, dropnumberraise = \the\dropnumberraise}%
    %\fi
    \edef\dr@psize{\strip@pt\dropnumbersize}%
}

\def\resetdropc@p{%The above code is in \lowercase which  breaks L and R
  \message{Setting L drop-cap size to \dr@psize}%
  \setp@ram{fontsize}{cL}{\dr@psize}%
  \g@tfontname{c}\x@\let\csname font<\f@ntstyle>\endcsname=\relax
  \setc@rdstat{R}%
  \setLRspecific
  \dropnumbersize=0pt
  \calcdr@psize
  \g@tfontname{c}\x@\let\csname font<\f@ntstyle>\endcsname=\relax
  \message{ Setting R drop-cap size to \dr@psize}%
  \setp@ram{fontsize}{cR}{\dr@psize}%
  %\x@\let\csname font<cL>\endcsname=\relax %
  %\x@\let\csname font<cR>\endcsname=\relax %
}
%-csty_dropchap

%+csty_strippt
\let\E=\empty
{\catcode`P=12 \catcode`T=12 \lowercase{\gdef\@strip@pt#1PT#2\E{#1} \xdef\@pt{PT}}}
\def\strip@pt#1{\x@\x@\x@\@strip@pt\x@\the\x@ #1\@pt\E}
%-csty_strippt

%+csty_hangverse
\def\AfterVerseSpaceFactor{2}
\newif\ifOmitChapterNumber
\newif\ifc@ncelfirstverse
\def\simpleprintv@rse{\AdornVerseNumber{\v@rsefrom}\ifx\v@rsefrom\v@rseto       %(2)
                 \else\endash\AdornVerseNumber{\v@rseto}\fi}
\def\hangprintv@rse{\ifx\v@rsefrom\v@rseto\relax\AdornVerseNumber{\v@rsefrom}%
    \else
         \dimen1=\SuperscriptFactor\baselineskip \multiply\dimen1 by 2
         \getp@ram{baseline}{v}\baselineskip=\ifx\p@ram\relax\baselineskip\else\p@ram\fi
         \dimen0=\SuperscriptFactor\baselineskip \advance\dimen0 by -\baselineskip
         \setbox1=\hbox{\endash\AdornVerseNumber{\v@rseto}}%
         \setbox0=\vtop{\hbox to \wd1{\hfil\AdornVerseNumber{\v@rsefrom}}%
                        \kern\dimen0\box1}%
         \ht0=0.5\dimen1 \dp0=0pt
         \hbox{\box0}\fi}
\let\printv@rse=\simpleprintv@rse                                               %(1)
\def\@ne{1}
\def\AdornVerseNumber#1{#1}                                                     %(3)

% put \hangversenumber into the <start> hook for a style such as \q1
% in order to 'hang' verse numbers into the paragraph indent of the style
\def\hangversenumber{\hangingversetrue\kern-1sp\relax}
%-csty_hangverse

% size to use for drop-cap style numbers; automatically calculated if not set
\newdimen\dropnumbersize
\newdimen\dropnumberraise

%+csty_define-hooks
% other modules can use \addtoversehooks to insert macros that will be executed at each verse
\def\addtoversehooks#1{\x@\global\x@\v@rsehooks\x@{\the\v@rsehooks #1}}
\def\addtopreversehooks#1{\x@\global\x@\prev@rsehooks\x@{\the\prev@rsehooks #1}}
\newtoks\v@rsehooks
\newtoks\prev@rsehooks
% A CV hook is executed only for a particular CV when the verse milestone occurs.
\def\setcvhook#1#2{\x@\gdef\csname cv-#1\endcsname{#2}}
\def\docvhook{\edef\c@rref{\id@@@\ifdiglot\c@rrdstat\fi\ch@pter.\v@rse}\csname cv-\c@rref\endcsname}
\addtoversehooks{\docvhook}
%-csty_define-hooks

\newif\ifch@pter \def\ch@plabel{}

% macros to switch digits between "letter" and "other" category; must be "letter" when reading USFM data,
% but "other" when we want to read numeric values
%+csty_fndigits
\def\m@kedigitsletters{\catcode`0=\el@ven \catcode`1=\el@ven \catcode`2=\el@ven \catcode`3=\el@ven
 \catcode`4=\el@ven \catcode`5=\el@ven \catcode`6=\el@ven \catcode`7=\el@ven
 \catcode`8=\el@ven \catcode`9=\el@ven \catcode`-=\el@ven \relax}
\def\m@kedigitsother{\catcode`0=\tw@lve \catcode`1=\tw@lve \catcode`2=\tw@lve \catcode`3=\tw@lve
 \catcode`4=\tw@lve \catcode`5=\tw@lve \catcode`6=\tw@lve \catcode`7=\tw@lve
 \catcode`8=\tw@lve \catcode`9=\tw@lve \catcode`-=\tw@lve \relax}
\def\el@ven{11}
\def\tw@lve{12}
%-csty_fndigits

\let\b@ok\relax
\def\ch@pter{}
\def\v@rse{}
\def\m@rknum{1}
\let\@ch@pter=\ch@pter
\let\@ch@pterR=\ch@pter
\let\@v@rse=\v@rse
\let\@v@rseR=\v@rse
\def\m@rkverse{\ifdiglot\m@rkverseDglot\else\m@rkverseNml\fi}
\def\m@rkverseNml{\mark{\b@ok:\ch@pter:\print@bleVerse}} %normal verse
\def\m@rkverseDglot{\mark{\b@ok:\ch@pter:\print@bleVerse}\edef\cur@ds{\g@tdstat}\marks\m@rknum{\csname b@ok\cur@ds\endcsname:\csname @ch@pter\cur@ds\endcsname:\print@bleVerse}} % diglot verse

\def\n@xtparstart{}
%+csty_addspecialhooks
\begingroup
\obeylines%
\gdef\@ddspecialhooks{% there are a few special USFM markers that we give "magic" properties
 \let\@H=\h%
 \def\h{\bgroup\deactiv@tecustomch@rs\catcode`\/=12
        \obeylines\@h}% \h gets stored as the book name (for references)
 \def\@h ##1^^M{\x@\gdef\csname b@ok\g@tdstat\endcsname{##1}\egroup}% store book id in \b@ok / b@okR 
 %
 \let\@CL=\cl%
 \def\do@CL{\global\ch@pterfalse\gdef\n@xtparstart{\pdfch@ptermark}\@CL}%
 \def\cl{\ifch@pter \let\n@xt=\do@CL \else \let\n@xt=\st@recl \fi \n@xt}%
 \def\st@recl{\bgroup\obeylines\@cl}% \cl gets stored as chapter label and changes \c format
 \def\@cl ##1^^M{\x@\gdef\csname ch@plabel\g@tdstat\endcsname{##1}\egroup}%
 %
 \let\@ID=\id%
 \def\id{\bgroup\obeylines\unc@tcodespecials \m@kedigitsother
   \catcode32=10 \@id}% \id gets stored and printed in the margin with cropmarks
 \def\@id ##1^^M{\gdef\c@rrID{##1}\uppercase{\@@id##1ZZZ\end}\egroup
        \gdef\b@okShort{}%Prevent roll-over of short-form book name
        \csname bookstart-all\endcsname
        \csname bookstart-\id@@@\endcsname}%
 %
 \def\b{\endlastp@rstyle{b}\bgroup % End previous par before making a gap
   \getp@ram{baseline}{b}\ifx\p@ram\relax
     \s@tbaseline{p}\vskip\baselineskip
    \else
      \vskip\p@ram
    \fi\egroup} 
 \def\fig{\m@kedigitsother\ptx@fig}% \fig has its own special macro to parse the fields
 %
 \let\nb=\ptx@nb% \nb is a special code that suppresses a paragraph break across \c
 \global\let\@k=\k
 \def\setkr@f##1{\edef\kr@f{\zap@space ##1 \empty}}
 \def\k##1\k*{%\k processing
    \edef\kr@f{\detokenize{##1}}%
    \x@\setkr@f\x@{\kr@f}%
    \message{\kr@f}%
    \@k ##1\endch@rstylen* %
    \runtrigg@rsother{k.\kr@f}%
  }
}%

\endgroup

\def\unc@tcodespecials{\def\do##1{\catcode`##1=12 }\dospecials}
\def\@@id#1#2#3#4\end{\gdef\id@@@{#1#2#3}} % get first 3 chars of the \id
\def\ptx@fig #1\fig*{\d@figure{#1}\m@kedigitsletters}                           %(1)
%-csty_addspecialhooks

%+csty_stack
% Comma Separated stack
\def\E{}
\def\cstackpop#1,#2\E{#2}
\def\cstackpush#1#2{#2,#1}
\def\cstackpeek#1,#2\E{#1}
\def\cstackup#1,#2\E{\edef\tmp{#2}\ifx\tmp\empty\let\n@x=\relax\else\let\n@x=\cstackup\fi\n@x #2\E\edef\tmp{#1}\ifx\tmp\empty\else\d@ #1\E\fi}                  %(1)
\def\cstackdown#1,#2\E{\edef\tmp{#1}\ifx\tmp\empty\else\d@ #1\E\fi\edef\tmp{#2}\ifx\tmp\empty\let\n@x=\relax\else\let\n@x=\cstackdown\fi\n@x #2\E}
\def\cstacktop#1,#2\E{\edef\temp{#1}\ifx\temp\empty\else\d@ #1\E\fi}
\def\cstackrelax#1\E{}
%-csty_stack

%+csty_mstack
% marker (comma) stack operations (mcstack)
\gdef\mcstack{+,} 
\let\mcstack@mpty\mcstack
\def\cstackempty{,}
\def\mcpopsimple{\traceNum{s}{popsimple stack: \mcstack}\xdef\mcstack{\x@\cstackpop\mcstack\E}\ifx\mcstack\empty\global\let\mcstack\mcstack@mpty\fi}
\def\mcpush#1{\traceNum{s}{push #1 onto \mcstack}\xdef\mcstack{#1,\mcstack}}
\def\mcup{\x@\cstackup\mcstack\E}
\def\mcdown{\x@\cstackdown\mcstack\E}
\def\mctop{\x@\cstacktop\mcstack\E}
\def\mctopnoms{\let\d@a=\d@\gdef\d@##1+##2\E{\if ##1m\else\d@a ##1+##2\E\let\d@=\cstackrelax\fi}\mcdown}
\def\mcstackdown#1,#2\E{\let\n@x=\mcstackdown\edef\tmp{#1}%Iftemp, then rebulild mcstack with the modified/saved portion (msst@ck) on top, then any insertion (inst@ck) and  the unprocesed parts of the stack, and stop
    \ifx\tmp\empty\let\n@x=\cstackrelax\else\d@b #1\E\iftemp\xdef\mcstack{\msst@ck\inst@ck #2}\let\n@x=\cstackrelax\fi\fi\n@x #2\E}
\def\mcpop{\traceNum{s}{mcpop stack: \mcstack}\global\tempfalse\xdef\inst@ck{}\xdef\msst@ck{}% Pop the first non-milestone
    \def\d@b##1+##2\E{\if ##1m\xdef\msst@ck{##1+##2,\msst@ck}\else\global\temptrue\fi}%
    \x@\mcstackdown\mcstack\E\ifx\mcstack\empty\global\let\mcstack\mcstack@mpty\fi}

\def\mcpushunderms#1{\traceNum{s}{mcpushunder stack(#1): \mcstack}\global\tempfalse\edef\msst@ck{}\xdef\inst@ck{#1,}% push #1 above the first non-milestone
    \def\d@b##1+##2\E{\trace{s}{[##1+##2] (\msst@ck)}\if ##1\relax\relax\xdef\inst@ck{\inst@ck+,}\temptrue\else\if ##1m\relax\xdef\msst@ck{\msst@ck##1+##2,}\else\xdef\inst@ck{\inst@ck##1+##2,}\global\temptrue\fi\fi}%
    \x@\mcstackdown\mcstack\E\trace{s}{->\msst@ck [\iftemp t\else f\fi], '\mcstack'}\iftemp\else\xdef\mcstack{\inst@ck\mcstack}\fi}

% milestone stack (MScstack)
%\gdef\MScstack{+,}  
%\let\MScstack@mpty\MScstack
%\def\MScup{\x@\cstackup\MScstack\E}
%\def\MScdown{\x@\cstackdown\MScstack\E}
%\def\MScpush#1{\traceNum{s}{push #1 onto milestone stack \MScstack}\xdef\MScstack{#1,\MScstack}}

% Test to see if a new THING pops other things.
\def\mct@stname#1#2{#1-mcp@ps-#2}
\def\mcp@pCont#1#2{\edef\t@@st{\mct@stname{#1}{#2}}\x@\xdef\csname\t@@st\endcsname{Y}} % Pop and continue
\def\mcp@pEnd#1#2{\edef\t@@st{\mct@stname{#1}{#2}}\x@\xdef\csname\t@@st\endcsname{P}} % Pop and end.
\def\mcnp@pSt@re#1#2{\edef\t@@st{\mct@stname{#1}{#2}}\x@\xdef\csname\t@@st\endcsname{S}} % no pop, Store and continue
%defs for comparison purposes 
\def\ss@Char{C}%
\def\ss@ChrP{c}%
\def\ss@Para{P}%
\def\ss@Note{N}%
%\def\ss@MstnS{M}% Static milestones (unused)
\def\ss@Mstn{m}% Floating milestones (always above a par style)
\def\ss@Ctgy{t}%
\def\ss@Sbar{s}%

\mcp@pCont{P}{P}% new P pops P
\mcp@pCont{P}{c}% new P pops c (\+char)
\mcp@pCont{P}{C}% new P pops C (\char)
\mcp@pCont{C}{c}% new C pops c
\mcp@pCont{C}{C}% new C pops C
\mcp@pCont{s}{C}% Side bars pop character styles.
\mcp@pCont{s}{c}% Side bars pop character styles.
\mcp@pCont{t}{t}% new cat pops old cat
\mcnp@pSt@re{*}{m}% Milestones are always stored.
%Style end pops:
\mcp@pCont{s*}{t}% sidebar end pops caT
\mcp@pCont{s*}{P}% sidebar end pops Paragraph
\mcp@pCont{s*}{c}% sidebar end pops embedded charstyle
\mcp@pCont{s*}{C}% sidebar end pops Charstyle
\mcp@pEnd{s*}{s}% sidebar end pops ONE sidebar, then finish
\mcp@pEnd{t*}{t}% cat end pops one old cat, then finish
\mcp@pCont{N*}{c}% Ending Note pops c
\mcp@pCont{N*}{C}% Ending Note pops C
\mcp@pCont{tc*}{C}% Ending table cell pops C (\char)
\mcp@pCont{tc*}{c}% Ending table cell pops C (\char)

%No point going below these for font styling, etc.
\def\mcb@rrier#1{\x@\let\csname isb@rrier-#1\endcsname\empty}
\mcb@rrier{P}
\mcb@rrier{N}
\mcb@rrier{s}
%Are these style modifiers (category or milestone)  or actual styles?
\def\msm@dfyname#1{#1-is-modifyer}
\def\msm@difyer#1{\edef\t@@st{\msm@dfyname{#1}}\x@\xdef\csname\t@@st\endcsname{Y}}
\def\g@tmodifyer#1{\edef\t@@st{\msm@dfyname{#1}}\x@\let\x@\t@stme\csname\t@@st\endcsname}
\msm@difyer{t}
\msm@difyer{M}
\msm@difyer{m}

\newif\ifp@pping
\p@ppingfalse
\def\last@popped@parstyle{}
\def\itp@psstore{}
\def\endit@c{\endch@rstyle*}
\def\endit@C{\endch@rstyle*}
\def\whileitp@ps#1+#2\E{% This almost does the same as \end@llcharstyle, but uses the new mechanism
  \p@ppingtrue
  \trace{s}{whileitp@ps:\mcch@cking:#1+#2 (\mcstack)}%
  \x@\let\x@\tmp\csname\mct@stname{\mcch@cking}{#1}\endcsname
  \ifx\tmp\relax %No specific style pop, is there a generic?
    \x@\let\x@\tmp\csname\mct@stname{*}{#1}\endcsname
  \fi
  \trace{s}{whileitp@ps result:\tmp}%
  \if S\tmp\relax % Store it?
     \edef\itp@psstore{#1+#2,\itp@psstore}%
     \mcpopsimple
  \else
    \if Y\tmp\relax  %end it and pop it
      \if #1\ss@Para\relax\xdef\last@popped@parstyle{#2}\fi
      \ifcsname endit@#1\endcsname
        \trace{s}{endit@#1}% endit@ macros are assumed(requrired) to call mcpop 
      	\csname endit@#1\endcsname
      \else 
	\mcpopsimple
      \fi
    \else
      \let\d@=\cstackrelax %stop here
      \if P\tmp\relax % ....but end it and pop first
	 \ifcsname endit@#1\endcsname
	   \trace{s}{endit@#1}% endit@ macros are assumed(requrired) to call mcpop 
	   \csname endit@#1\endcsname
	 \else 
	   \mcpopsimple
	 \fi
       \fi
     \fi
  \fi
  \p@ppingfalse
}
\def\end@llpoppedstyles#1{\let\itp@psstore\empty\edef\mcch@cking{#1}\let\d@=\whileitp@ps\mcdown\ifx\itp@psstore\empty\else\edef\mcstack{\itp@psstore\mcstack}\fi}

\def\s@tstyst@k#1{%Get a + separated list of styles that ought to uniquely define a font/etc.
  %List excludes marker #1 and stops at a barrier (e.g. a par/note/sidebar)
  %defines \styst@kskip to be the skipped value and \styst@kfirst to first value.
  \edef\styst@kskip{#1}%
  \def\d@##1+##2\E{\ifcsname isb@rrier-##1\endcsname\let\d@=\cstackrelax\fi%stop here?
    \edef\tmp{##2}\csname d@code-##1\endcsname
    \ifx\tmp\empty\else\ifx\tmp\styst@kskip\else
      \ifx\styst@k\empty
        \edef\styst@kfirst{\tmp}\edef\styst@k{\tmp}%
      \else
        \edef\styst@k{\styst@k+\tmp}%
    \fi\fi\fi
  }\mcdown
  \trace{s}{styst@k -> (\styst@kskip/\styst@kfirst/\styst@k)}%
}
\let\styst@kfirst\empty
\let\styst@kskip\empty
\let\styst@k\empty
%-csty_mstack

%+csty_stylesheet
% \stylesheet{...} reads a Paratext stylesheet line by line
%
{% Horrible piece of parsing to ignore everything after # except when there's #! at the start of a line.
  \catcode`\~=6
  \catcode`\#=12
  \gdef\styl@sheetline~1{%
     \x@\styl@sh@@tline ~1#!#\relax
  }
  \gdef\styl@sh@@tline~1#~2!~3#~4\relax{%
     %\trace{s}{\detokenize{ReadLine '~1' # '~2' ! '~3'}}%
     \catcode`\~=13
     \catcode`\#=6
     \def\tmpa{~1}\def\tmpb{~3}%
     \def\tmpc{~1~2}%
     \ifx\tmpc\empty%There's a line-start #!
       \ifx\tmpb\empty\else % and the line isn't empty
         ~3\relax
       \fi
     \else %A normal line
       \ifx\tmpa\empty\else %that's not empty
         ~1\relax
       \fi
     \fi
  }
}
\newif\ifc@ntinue
\def\c@tegory{}
\newread\styl@sheet
\def\stylesheet#1{
 \let\oldc@tegory=\c@tegory
 \m@kedigitsother
 \let\save@regular=\regular \let\regular=\Regular
 \let\save@bold=\bold \let\bold=\Bold
 \let\save@italic=\italic \let\italic=\Italic
 \openin\styl@sheet="#1" \c@ntinuetrue                      %(1)
 \ifeof\styl@sheet\errmessage{Paratext stylesheet "#1" not found}\else
   \message{Reading Paratext stylesheet "#1" (\c@tegory)...}%
   \endlinechar=-1
   %\catcode`\#=5 % paratext comment char
   \loop
    \catcode`\#=12
    \read\styl@sheet to \th@line                            %(2)
    \styl@sheetline{\th@line}
   % \th@line \relax
    \ifeof\styl@sheet \c@ntinuefalse \fi
    \ifc@ntinue\repeat
   \endlinechar=13
   \closein\styl@sheet
   \catcode`\#=6 % restore default TeX catcode
 \fi
 \let\regular=\save@regular
 \let\bold=\save@bold
 \let\italic=\save@italic
 \ifx\oldc@tegory\c@tegory\else\ifsubc@ll\else\message{Error: Stylesheet changed category from '\oldc@tegory' to '\c@tegory'.}\fi\fi%
 \global\let\c@tegory=\oldc@tegory
}
\newif\ifsubc@ll \subc@llfalse
%-csty_stylesheet

\newif\iflastptxfile
\newif\iflastpage
\newdimen\origb@selineskip %Save the initial baselineskip here


%+csty_onetime
\def\@netimesetup{
 % stuff to execute after loading all stylesheets but before processing the first USFM file
 \ifdiglot
  \trace{d}{Onetimesetup, (\c@rrdstat)}%
 \else
   \ifRTL
     \BookOpenLefttrue
   \fi
 \fi
 \origb@selineskip=\baselineskip
 \s@tupsizes
 \defineheads
 \ifnum 1=\ifVisTrace 1 \else \ifVisTraceExtra 1 \else 0\fi\fi 
   \font\VisTracefont="Arial":color=3f7f3f at 6pt\fi
 \ifdiglot\setc@rdstat{L}%
 \fi
 %\global\lastptxfiletrue
 \let\@netimesetup=\relax}                                                      %(1)

\def\@netimesetuplater{
 \@ddcvhooks
 \@ddspecialhooks
 \the\@nithooks
 \let\@netimesetuplater=\relax}                                                      %(1)
%-csty_onetime

\newif\iftildenbsp
\tildenbsptrue

\def\prepusfm{
 %\catcode`\$=12
 \catcode`\^=12 % make these printable
 \catcode`\&=12
 \iftildenbsp
  \catcode`\~=13 %Normal value
 \else
  \catcode`\~=13 %printable
 \fi
 \catcode`\#=12
 \catcode`\{=12 \catcode`\}=12
 \catcode`\_=11 % treat as letter for TE custom styles
 \catcode`\/=\active
 \catcode13=10
 \catcode`+=11 % treat as letter
 \activ@tecustomch@rs
 % The last comment on all matters
 \catcode`\%=12
 \m@kedigitsletters
}

\def\unprepusfm{
 \m@kedigitsother
 \catcode`\%=14 % The return of commentary
 \deactiv@tecustomch@rs
 \catcode13=5
 \catcode`\/=12
 \catcode`\#=6 \catcode`\%=14 % restore TeX meanings for those we might use
 \catcode`\{=1 \catcode`\}=2
 \catcode`+=\pl@scatcode % don't treat as letter any more
}

% Read the files associated with this book: usfm, adjustment list, picture list
%+csty_ptxfile_intro
\def\ptxst@rtp@ge{1}
\def\ptxfile#1{
 \saveLRspecificOrig%This becomes a \relax after first use. Always call it.
 \kill@PossParamCache
 \xdef\ptxst@rtp@ge{\the\pageno}%
 \ifdiglot
    \ifx\c@rrdstat\empty
      \gdef\c@rrdstat{L}%
    \fi
    \setLRspecific% \@netimesetup needs actual values, in a diglot there may be no use of generic FontSizeUnit, etc.
  \fi
 \@netimesetup
 \ifdiglot\bgroup%This must be outside of @onetimesetup as there's no guarantee that diglot will be true for all ptxfiles.
   \diglots@tup
   \dimen0=\baselineskip
   \setc@rdstat{R}%
   \showLRspecific
   \setLRspecific\s@tb@dyb@seline{R}%
   \global\baselineDelta=\baselineskip
   \saveLRspecificSide{R}%
   \baselineskip=\dimen0
   \setc@rdstat{L}%
   \showLRspecific
   \setLRspecific\s@tb@dyb@seline{L}%
   \global\advance\baselineDelta by -\baselineskip
   \saveLRspecificSide{L}%
   \baselineskip=\dimen0
   \egroup
   \global\let\gridb@x\diglotgr@db@x
 \else
   \ifsquashgridbox\global\let\gridb@x\gr@db@@x\else\global\let\gridb@x\gr@db@x\fi % liberated from onetimesetup, as it might not be one-time.
 \fi
 \@netimesetuplater
 \gdef\ch@plabel{}
 \gdef\ch@plabelR{}
 \initp@rastyles
 \initn@testyles
 \ifendbooknoeject\else\p@geonetrue\fi
%-csty_ptxfile_intro
%+csty_ptxfile_start
 \openadjlist "\the\AdjListPath#1.adj"
 \openpiclist "\the\PicListPath#1.piclist"
 \openpicpages "\jobname.picpages"
 \lastpagefalse
 \prepusfm
 \openin\t@stread="\the\PtxFilePath#1"
   \ifeof\t@stread \def\n@xt{\MSG{USFM file "\the\PtxFilePath#1" not found -- ignored}}
   \else \closein\t@stread \def\n@xt{\input "\the\PtxFilePath#1"\relax}\fi
 \n@xt
%-csty_ptxfile_start
%+csty_ptxfile_end
 \ifhmode \unskip\end@llpoppedstyles{P}\par \fi
 \ifsk@pping\egroup\fi
 \endt@ble
 \ifdiglot\enddigl@t\fi
 \ifx\b@ok\relax\else\csname bookend-\id@@@\endcsname\relax\fi
 \csname bookend-all\endcsname
 \the\@ndptxhooks
 \ifnum \ifnotesEachBook 1\else\iflastptxfile 1\else 0\fi\fi =1 \the\placendnotes\fi
 \iflastptxfile\closepiclist\fi
 \closeadjlist
 \unprepusfm
 \lastpagetrue
 \singlecolumn\iflastptxfile\csname bookend-final\endcsname\fi\bookendpagebreak
 %\ifendbooknoeject\else\global\output={\global\setbox255=\box\voidb@x}\eject\xdef\p@gefirstmark{}\setbox\partial=\box\voidb@x\fi
 \ifendbooknoeject\else\global\output={\shipout\vbox{\box\partial\box255}}\eject\xdef\p@gefirstmark{}\setbox\partial=\box\voidb@x\fi
 \global\output={\onecol}
}
%-csty_ptxfile_end
\newread\t@stread
\newtoks\AdjListPath % path to look for adjustment files
\newtoks\PicListPath % path to look for picture list files
\newtoks\PtxFilePath % path to look for main ptx input files

% mechanism to define active chars within the ptx files
\catcode`\~=\active
\def\DefineActiveChar#1#2{\count255=`#1
  \do@ctive=\x@\x@\x@{\x@\the\x@\do@ctive
    \x@\d@something\the\count255 }%
  \lccode`\~=\count255
  \def\t@mp{\noexpand#2} \lowercase{\edef~{\t@mp}}}
\newtoks\do@ctive

\def\@ctivate{\x@\edef\csname save-cat-\the\count255\endcsname{\the\catcode\count255}%
  \catcode\the\count255=\active\relax}
\def\de@ctivate{\catcode\the\count255=\csname save-cat-\the\count255\endcsname\relax}

\def\activ@tecustomch@rs{% activate all the chars configured with \DefineActiveChar
 \def\d@something{\afterassignment\@ctivate \count255=}\the\do@ctive}  
\def\deactiv@tecustomch@rs{% deactivate all the chars configured with \DefineActiveChar
 \def\d@something{\afterassignment\de@ctivate \count255=}\the\do@ctive}  

% use numbers to allow sequences to work in \fig .. \fig*
\def\openbracket{\char91\ignorespaces}
\def\openparen{\char40\ignorespaces}

\DefineActiveChar{[}{\openbracket} % make these skip following spaces
\DefineActiveChar{(}{\openparen}   % (useful at end-of-line before new verse)

%+csty_slash
\catcode`\/=\active
\def/{\futurelet\n@xt\sl@sh}
\def\sl@sh{\ifx\n@xt/\let\n@xt\sl@shbreak\else\let\n@xt\sl@shprint\fi\n@xt}
\def\sl@shbreak/{\unskip\penalty-250{} \ignorespaces}
\def\sl@shprint{\char`\/}
\catcode`\/=12
%-csty_slash
%+csty_category
% Define the current category
\def\s@tc@tprefix#1{%
  \def\c@tegory{#1}%global or NOT global? No apparent issue with either, so stick with local, as that allows nesting.
  \s@tc@tpr@fix
}
\def\s@tc@tpr@fix{%
  \ifx\c@tegory\empty\let\c@tprefix\empty
  \else
    \edef\c@tprefix{cat:\c@tegory|}%
  \fi
  \trace{sc}{Stylesheet prefix for \c@tegory: '\c@tprefix'}%
}
\def\@ndc@t{%
  \ifx\c@tegory\empty
    \trace{sc}{@ndc@t called with empty category. Eh?}%
  \else
    \cl@singhooks{end}{cat}% 
    \end@llpoppedstyles{t*}%pop styles closed by and end of t
    \endgroup %End the group started between the cat groups     %(3)
    \cl@singhooks{after}{cat}%
    \s@tc@tprefix{}%
    \the\afterh@@ks
  \fi
  \egroup % End the group from the containing code.             %(4)
}
% remember as c@t, onetime setup will define \cat to this, protecting the definition from stylesheet
\def\nofin@lspace #1 #2\E{#1}%Eat a final space
\def\c@t #1\cat*{%
  \ifx\c@tegory\empty\else                                      %(5)
    \trace{sc}{Odd situation: two \\cat commands in one group or nested categories? Assuming nesting.}%
    \end@llpoppedstyles{t}%pop styles closed by a start of t, in case this IS 2 cat commands
    % Assume nesting and don't run any endhooks. Otherwise we'd do this:
    %\op@ninghooks{end}{cat}% 
    %\endgroup %End the group started between the cat groups  
    %\cl@singhooks{after}{cat}%
  \fi
  \x@\s@tc@tprefix{\nofin@lspace #1 \E}%
  \the\c@th@@ks% Run anythingthe enclosing code wants
  \op@ninghooks{before}{cat}% 
  \ifhmode\par\fi
  \begingroup % This group will be closed between the end and after hooks of endc@t %(1)
  \mcpush{t+#1}%
  \op@ninghooks{start}{cat}%
  \let\styst@k=\empty
  \s@tstyst@k{#1}%
  \bgroup % This group will be closed by the end-of footnote marker / other container.  %(2)
  %I.e. we're borrowing the egroup from other bits of code.  
  \aftergroup\@ndc@t %
}
\global\let\c@tprefix\empty % category-specific prefix
\global\let\mspr@fix\empty % Milestone-specific prefix
%-csty_category

%+csty_hooks
%Hook-runners for paragraph and character styles
\def\op@ninghooks#1#2{% for <start> and <before> hooks
   \csname #1-#2\endcsname % 
   \ifx\c@tegory\empty\else\csname #1-\c@tprefix#2\endcsname\fi
   \ifdiglot\setsid@ % \MSG{start-\thisch@rstyle\sid@}%
     \csname #1-#2\sid@\endcsname\relax % handle side-specific <before> hook
     \ifx\c@tegory\empty\else
        \csname #1-\c@tprefix#2\sid@\endcsname %side-specific and category-specific
     \fi
   \fi
}
\newtoks\c@th@@ks
\newtoks\afterh@@ks
\def\cl@singhooks#1#2{% for <end> and <after> hooks. For <after> hooks, it's necessary to end the group after these are defined 
  \global\let\n@xt\relax
  \global\let\n@@xt\relax
  \global\let\n@@@xt\relax
  \global\let\n@@@@xt\relax
  %\global\afterh@@ks{}%
  %\tracingassigns=1
  \ifdiglot\setsid@ % \MSG{end-\thisch@rstyle\sid@}%
    \ifx\c@tegory\empty\else
      \x@\global\x@\let\x@\n@xt
        \csname #1-\c@tprefix#2\sid@\endcsname %side-specific and category-specific
      \x@\global\afterh@@ks{\n@xt}%
    \fi
    \x@\global\x@\let\x@\n@@xt
      \csname #1-#2\sid@\endcsname % handle side-specific <end> hook
    \x@\global\x@\afterh@@ks\x@{\the\afterh@@ks\n@@xt}%
  \fi
  \ifx\c@tegory\empty\else
    \x@\global\x@\let\x@\n@@@xt
      \csname #1-\c@tprefix#2\endcsname
    \x@\global\x@\afterh@@ks\x@{\the\afterh@@ks\n@@@xt}%
  \fi
  \x@\global\x@\let\x@\n@@@@xt
    \csname #1-#2\endcsname%
  \x@\global\x@\afterh@@ks\x@{\the\afterh@@ks\n@@@@xt\global\afterh@@ks{}}% Notice the self-clearing %(1)
  %\showthe\afterh@@ks
  \edef\@@@a{#1}%                                                  %(2)
  \ifx\@@@a\@fter\else\the\afterh@@ks\fi
}
\edef\@fter{after}
%-csty_hooks
% Create registers to hold configuration information, set defaults
\newdimen\FontSizeUnit		\FontSizeUnit=1bp % units for font sizes in Paratext stylesheet
\newdimen\IndentUnit		\IndentUnit=1in % units for indents
\newdimen\PaperWidth		\PaperWidth=210mm
\newdimen\PaperHeight		\PaperHeight=297mm
\newdimen\MarginUnit		\MarginUnit=1in % units for margins
\newdimen\BindingGutter		\BindingGutter=5mm
\def\LineSpacingFactor{1.0} % scale factor used for line spacing
\def\VerticalSpaceFactor{1.0} % scaling factor applied to space before/after styles
\def\TopMarginFactor{1.0}
\def\BottomMarginFactor{\TopMarginFactor}
\def\SideMarginFactor{1.0}
\def\ColumnGutterFactor{15} % relative to FontSizeUnit
\def\HeaderPosition{0.5} % pos of baseline from top of page, relative to MarginUnit
\def\FooterPosition{0.5} % pos of baseline from bottom of page, relative to MarginUnit
\def\DiglotLeftFraction{0.5} % In case texts fit better with unequal columns
\def\DiglotRightFraction{0.5} %

\newcount\TitleColumns \TitleColumns=1
\newcount\IntroColumns \IntroColumns=1
\newcount\BodyColumns  \BodyColumns=1

\newif\ifBindingGutter % \BindingGutter won't be used unless this is set to true
\newif\ifDoubleSided \DoubleSidedtrue % binding gutter on alternate sides; use odd/even headers
\def\debugBL{\MSG{\f@ntstyle, Baseline: \the\baselineskip}} % for scattering in usfm as desired.
% calculate various dimensions based on the factors, units, etc that have been defined
%+csty_setupsizes
\def\s@tb@dyb@seline#1{%Parameter is {} for monoglot, L / R for diglot.
 \baselineskip=\origb@selineskip
 \le@dingunit=\LineSpacingFactor\FontSizeUnit
 \onel@neunit=\LineSpaceBase\le@dingunit
 \verticalsp@ceunit=\VerticalSpaceFactor\le@dingunit
 \trace{F}{le@dingunit(\the\le@dingunit)=\LineSpacingFactor * \the\FontSizeUnit, onel@neunit(\the\onel@neunit)=\LineSpaceBase * \the\le@dingunit}
 \ifdim\baselineskip < 1pt \baselineskip=\onel@neunit\fi % If the baselineskip has been specifically
                                                           % set it will remain. Otherwise, the default
                                                           % of 14 will be applied here and set text will
                                                           % hold to the grid.
 \getp@ram{baseline}{p#1}\ifx\p@ram\relax
   \s@tbaseline{p#1}\setp@ram{baseline}{p#1}{\the\baselineskip}%
   \x@\xdef\csname b@selineskip#1\endcsname{\the\baselineskip}%
   \MSG{Baselineskip for p#1 was undefined, now set to \the\baselineskip}%
 \else
   \MSG{Baselineskip for p#1 defined, as \the\baselineskip}%
   \x@\xdef\csname b@selineskip#1\endcsname{\the\baselineskip}%
 \fi
}
\def\s@tupsizes{
 \s@tb@dyb@seline{}%
 %\tracingifs=1
 \lineskiplimit=-9\le@dingunit
 \lineskip=0pt
 \s@tbaseline{p}%
 \NoteCallerWidth=1.1ex %Something sane?
 \topskip=\baselineskip\MSG{topskip=\the\topskip}
 \splittopskip=\baselineskip
 \gutter=\ColumnGutterFactor\FontSizeUnit
 \dimen0=\PaperWidth \dimen2=\SideMarginFactor\MarginUnit
 \advance\dimen0 by -2\dimen2
 \ifBindingGutter \advance\dimen0 by -\BindingGutter \fi
 \advance\dimen0 by -1\ExtraRMargin
 \textwidth=\dimen0
 \colwidth=0.5\textwidth \advance\colwidth by -0.5\gutter\advance\colwidth by -\columnshift
% Diglot dimensions
 \advance\dimen0 by -\gutter\advance\dimen0 by -2\columnshift
 \ifcsname DiglotLFraction\endcsname\else
    \let\DiglotLFraction=\DiglotLeftFraction
 \fi
 \ifcsname DiglotRFraction\endcsname\else
    \let\DiglotRFraction=\DiglotRightFraction
 \fi
 \def\col@do##1{\csname column##1width\endcsname=\csname Diglot##1Fraction\endcsname\dimen0}%
 \x@\each@col\diglot@list\E
 %\columnLwidth=\DiglotLeftFraction\dimen0
 %\columnRwidth=\DiglotRightFraction\dimen0
 \hsize=\textwidth \advance\hsize by -2\columnshift
 \topm@rgin=\TopMarginFactor\MarginUnit
 \advance\topm@rgin by -\topskip \advance\topm@rgin by 12\FontSizeUnit
 \bottomm@rgin=\BottomMarginFactor\MarginUnit
 \dimen0=\PaperHeight
 \advance\dimen0 by -\topm@rgin
 \advance\dimen0 by -\bottomm@rgin
 \textheight=\dimen0
 \vsize=\textheight
 \iffalse % Code for testing breakable inserts. It breaks things!
   \dimen\topins=\textheight
   \dimen\bottomins=\textheight
   \dimen\topleftins=0.7\textheight
   \dimen\toprightins=0.7\textheight
   \dimen\bottomleftins=0.7\textheight
   \dimen\bottomrightins=0.7\textheight
   \dimen\bottomins=\textheight
   \dimen\verybottomins=\textheight
 \fi
 \ifrotate\pdfpagewidth=\PaperHeight \pdfpageheight=\PaperWidth\else
 \pdfpagewidth=\PaperWidth \pdfpageheight=\PaperHeight\fi
 \trace{p}{setupsizes: \the\pdfpagewidth, \the\pdfpageheight}
 \resetvsize
}
%-csty_setupsizes
\def\LineSpaceBase{14}
\newdimen\le@dingunit
\newdimen\onel@neunit
\newdimen\verticalsp@ceunit
\newdimen\topm@rgin
\newdimen\bottomm@rgin
\newdimen\textwidth
\newdimen\textheight
\newdimen\colwidth
\newdimen\ExtraRMargin \ExtraRMargin=0pt
\newdimen\gutter \gutter=20pt

\endinput
