#!/usr/bin/python3

import argparse, sys, os

try:
    import ptxprint
except ImportError:
    sys.path.append(os.path.join(os.path.dirname(__file__), "..", "lib"))
    import ptxprint

parser = argparse.ArgumentParser()
parser.add_argument('pid',nargs="?",help="Project id")
parser.add_argument('-p','--paratext',help="Path to Paratext Projects directory")
parser.add_argument('-d','--directory',default=".",help="Directory to store temporary files in")
parser.add_argument('-m','--macros',help="Directory containing TeX macros (paratext2.tex)")
# parser.add_argument('-t','--test', action='store_true',help="Quick start for a lazy typist")
args = parser.parse_args()

if args.paratext is None:
    args.paratext = ptxprint.runner.pt_settings

if not args.paratext:
    print("No Paratext Settings directory found")
    sys.exit(1)
else:
    args.paratext = args.paratext.replace("\\", "/")
    if args.paratext.endswith("/"):
        args.paratext = args.paratext[:-1]

# Where to find the default for -p
# HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Paratext\8:Settings_Directory
allprojects = []
for d in os.listdir(args.paratext):
    if os.path.exists(os.path.join(args.paratext, d, 'Settings.xml')):
        allprojects.append(d)
allprojects.sort()

mainw = ptxprint.PtxPrinterDialog(allprojects, args.paratext)

if args.pid:
    mainw.set("cb_project", args.pid)

def dojob(jobs, info, prjid, prjdir, tmpdir, logbuffer=None):
    donebooks = []
    for b in jobs:
        out = info.convertBook(b, tmpdir, prjdir)
        donebooks.append(out)
    info["project/books"] = donebooks
    if len(jobs) > 1:
        outfname = "ptxprint-{}_{}{}.tex".format(jobs[0], jobs[-1], prjid)
    else:
        outfname = "ptxprint-{}{}.tex".format(jobs[0], prjid)
    with open(os.path.join(tmpdir, outfname), "w") as texf:
        info.GenerateNestedStyles()
        texf.write(info.asTex(filedir=tmpdir))
    os.putenv("hyph_size", "32749")     # always run with maximum hyphenated words size (xetex is still tiny ~200MB resident)
    if info['project/useptmacros'] == "false":
        if not os.getenv('TEXINPUTS'):
            ptxmacrospath = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../src"))
            if not os.path.exists(ptxmacrospath):
                for b in (sys.USER_BASE, sys.prefix):
                    ptxmacrospath = os.path.abspath(os.path.join(b, 'ptx2pdf'))
                    if os.path.exists(ptxmacrospath):
                        break
            texinputs = [os.path.abspath(tmpdir), ptxmacrospath]
            os.putenv('TEXINPUTS', (";" if sys.platform=="win32" else ":").join(texinputs))
    elif sys.platform == "linux":
        if not os.getenv('TEXINPUTS'):
            mdirs = args.macros or "/usr/lib/Paratext8/xetex/share/texmf-dist/tex/ptx2pdf:/usr/lib/Paratext9/xetex/share/texmf-dist/tex/ptx2pdf"
            os.putenv('TEXINPUTS', ".:" + mdirs)
    runner = ptxprint.runner.call(["xetex", "--halt-on-error", outfname], cwd=tmpdir, logbuffer=logbuffer)
    delayed = outfname.replace(".tex", ".delayed")
    if os.path.exists(delayed):
        if runner is not None:
            runner.wait(200)
        runner = ptxprint.runner.call(["xetex", "--halt-on-error", outfname], cwd=tmpdir, logbuffer=logbuffer)
    if logbuffer is not None:
        if runner is not None:
            runner.wait(200)
        # logbuffer.bind_subprocess(None)
    print("cd {}; xetex {}".format(tmpdir, outfname))
    return outfname

def doit(printer):
    info = printer.info or ptxprint.Info(printer, args.paratext, printer.ptsettings)
    prjid = printer.get("cb_project")
    prjdir = os.path.join(args.paratext, prjid)
    # save config
    config = info.createConfig(printer)
    with open(os.path.join(prjdir, "ptxprint.cfg"), "w", encoding="utf-8") as outf:
        config.write(outf)
    tmpdir = os.path.join(prjdir, 'PrintDraft') if printer.get("c_useprintdraftfolder") else args.directory
    jobs = printer.getBooks()
    if printer.get("c_combine"):
        texfiles = [dojob(jobs, info, prjid, prjdir, tmpdir, logbuffer=printer.logbuffer)]
    else:
        texfiles = [dojob([j], info, prjid, prjdir, tmpdir, logbuffer=printer.logbuffer) for j in jobs]

    # Open the resulting PDF if it exists
    if len(jobs) > 1:
        pdfname = os.path.join(tmpdir, "ptxprint-{}_{}{}.pdf".format(jobs[0], jobs[-1], prjid))
    else:
        pdfname = os.path.join(tmpdir, "ptxprint-{}{}.pdf".format(jobs[0], prjid))
    if not printer.get("c_keepTemporaryFiles"):
        removeTempFiles(texfiles,tmpdir,info)
    # Need a way to check if a NEW PDF was generated, and not just open the PREVIOUS one and pretend that everything worked fine! :-(
    if sys.platform == "win32" and os.path.exists(pdfname):
        os.startfile(pdfname)

def removeTempFiles(texfiles,tmpdir,info):
    print("Deleting temporary files")
    # First delete files where there is only one per run
    for extn in ('delayed','parlocs','notepages', 'tex','log'):
        for t in texfiles:
            delfname = os.path.join(tmpdir, t.replace(".tex", "."+extn))
            # print("Deleting: " + delfname)
            try:
                # print("About to delete",delfname)
                os.remove(delfname)
            except OSError:
                print("Failed to delete temporary file: " + delfname)
    # Then delete the SFM files (1 per book)
    for delfname in info['project/books']:
        # print("Deleting: " + delfname)
        try:
            # print("About to delete",delfname)
            os.remove(delfname)
        except OSError:
            print("Failed to delete temporary file: " + delfname)
        
mainw.run(doit)
