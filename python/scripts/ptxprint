#!/usr/bin/python3

import argparse, sys, os, re, subprocess, img2pdf
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, Gdk
from shutil import copyfile, rmtree
from time import sleep

if getattr(sys, "frozen", False) and hasattr(sys, "_MEIPASS"):
    sys.stdout = open(os.devnull, "w")
    # sys.stdout = open("D:\Temp\ptxprint-sysout.tmp", "w")
    sys.stderr = sys.stdout
else:
    gi.require_version('GtkSource', '3.0')

try:
    import ptxprint
except ImportError:
    sys.path.append(os.path.join(os.path.dirname(__file__), "..", "lib"))
    import ptxprint

parser = argparse.ArgumentParser()
parser.add_argument('pid',nargs="?",help="Project id")
parser.add_argument('-p','--paratext',help="Path to Paratext Projects directory")
parser.add_argument('-d','--directory',default=".",help="Directory to store temporary files in")
parser.add_argument('-m','--macros',help="Directory containing TeX macros (paratext2.tex)")
parser.add_argument('-l','--logging',action="store_true",help="Output logging to terminal instead of logging window")
parser.add_argument('-e','--experimental',action="store_true",help="Enable experimental features")
# parser.add_argument('-t','--test', action='store_true',help="Quick start for a lazy typist")
args = parser.parse_args()

if args.paratext is None:
    args.paratext = ptxprint.runner.pt_settings

if not args.paratext:
    print("No Paratext Settings directory found")
    sys.exit(1)
else:
    args.paratext = args.paratext.replace("\\", "/")
    if args.paratext.endswith("/"):
        args.paratext = args.paratext[:-1]

# Where to find the default for -p
# HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Paratext\8:Settings_Directory
allprojects = []
for d in os.listdir(args.paratext):
    if os.path.exists(os.path.join(args.paratext, d, 'Settings.xml')):
        allprojects.append(d)
allprojects.sort()

css = ".printbutton:active { background-color: red; background-image: None }"
provider = Gtk.CssProvider()
provider.load_from_data(css.encode("utf-8"))
Gtk.StyleContext().add_provider_for_screen(Gdk.Screen.get_default(), provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)

mainw = ptxprint.PtxPrinterDialog(allprojects, args.paratext, working_dir=args.directory)
mainw.ExperimentalFeatures(args.experimental)

if args.pid:
    mainw.set("cb_project", args.pid)

def parselog(fname, rerunp=False, lines=20):
    loglines = []
    rerunres = False
    with open(fname, "r", encoding="utf-8", errors="ignore") as logfile:
        try:
            for i, l in enumerate(logfile.readlines()):
                if rerunp and l.startswith("PARLOC: Rerun."):
                    rerunres = True
                loglines.append(l)
                if len(loglines) > lines:
                    loglines.pop(0)
        except:
            loglines.append("Logfile missing: "+fname)
    return (loglines, rerunres)

def readfile(fname):
    try:
        with open(fname, "r", encoding="utf-8") as inf:
            res = "".join(inf.readlines())
        return res
    except FileNotFoundError:
        return ""

def dojob(jobs, info, prjid, prjdir, tmpdir, logbuffer=None):
    donebooks = []
    for b in jobs:
        out = info.convertBook(b, tmpdir, prjdir)
        donebooks.append(out)
    info["project/books"] = donebooks
    if len(jobs) > 1:
        outfname = "ptxprint-{}_{}{}.tex".format(jobs[0], jobs[-1], prjid)
    else:
        outfname = "ptxprint-{}{}.tex".format(jobs[0], prjid)
    info.update()
    with open(os.path.join(tmpdir, outfname), "w", encoding="utf-8") as texf:
        texf.write(info.asTex(filedir=tmpdir, jobname=outfname.replace(".tex", "")))
    os.putenv("hyph_size", "32749")     # always run with maximum hyphenated words size (xetex is still tiny ~200MB resident)
    os.putenv("stack_size", "32768")    # extra input stack space (up from 5000)
    ptxmacrospath = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../src"))
    if not os.path.exists(ptxmacrospath):
        for b in (getattr(sys, 'USER_BASE', '.'), sys.prefix):
            if b is None:
                continue
            ptxmacrospath = os.path.abspath(os.path.join(b, 'ptx2pdf'))
            if os.path.exists(ptxmacrospath):
                break
    if info['project/useptmacros'] == "false":
        if not os.getenv('TEXINPUTS'):
            texinputs = [os.path.abspath(tmpdir), ptxmacrospath]
            os.putenv('TEXINPUTS', (";" if sys.platform=="win32" else ":").join(texinputs))
    elif sys.platform == "linux":
        if not os.getenv('TEXINPUTS'):
            mdirs = args.macros or "/usr/lib/Paratext8/xetex/share/texmf-dist/tex/ptx2pdf:/usr/lib/Paratext9/xetex/share/texmf-dist/tex/ptx2pdf"
            os.putenv('TEXINPUTS', ".:" + mdirs)
    os.putenv("MISCFONTS", ptxmacrospath)
    numruns = 5
    while numruns > 0:
        if info["document/toc"] != "%":
            tocdata = readfile(os.path.join(tmpdir, outfname.replace(".tex", ".toc")))
        runner = ptxprint.runner.call(["xetex", "--halt-on-error", outfname], cwd=tmpdir, logbuffer=(logbuffer if not args.logging else None))
        if isinstance(runner, subprocess.Popen) and runner is not None:
            runner.wait(200)
            info.res = runner.returncode
        else:
            info.res = runner
        print("cd {}; xetex {} -> {}".format(tmpdir, outfname, info.res))
        (info.loglines, rerun) = parselog(os.path.join(tmpdir, outfname.replace(".tex", ".log")), rerunp=True, lines=300)
        if info.res:
            break
        elif info["document/toc"] != "%" and not rerun:
            tocndata = readfile(os.path.join(tmpdir, outfname.replace(".tex", ".toc")))
            rerun = tocdata != tocndata
            if rerun:
                print("Rerunning because the Table of Contents was updated")
            else:
                break
        elif rerun:
            print("Rerunning because inline chapter numbers moved")
        else:
            break
        numruns -= 1
    print("Done")
    return outfname

def doit(printer):
    info = printer.info or ptxprint.Info(printer, args.paratext, printer.prjid)
    prjid = printer.get("cb_project")
    prjdir = os.path.join(args.paratext, prjid)
    if prjid is None or not len(prjid):     # can't print no project
        return
    # save config
    info.update()
    info.GenerateNestedStyles()
    config = info.createConfig(printer)
    invPW = printer.get("t_invisiblePassword")
    if invPW == None or invPW == "": # This config is unlocked
        # So it it safe/allowed to save the current config
        printer.saveConfig(config)
    else:
        print("Current Config is Locked, so changes have NOT been saved")
    tmpdir = os.path.join(prjdir, 'PrintDraft') if printer.get("c_useprintdraftfolder") else args.directory
    if not os.path.exists(tmpdir):
        os.makedirs(tmpdir)
    jobs = printer.getBooks()

    if printer.get("c_includeillustrations"):
        gatherIllustrations(jobs, prjid, prjdir, printer)

    info.changes = None
    if printer.get("c_combine"):
        texfiles = [dojob(jobs, info, prjid, prjdir, tmpdir, logbuffer=printer.logbuffer)]
    else:
        texfiles = [dojob([j], info, prjid, prjdir, tmpdir, logbuffer=printer.logbuffer) for j in jobs]
    # Work out what the resulting PDF was called
    if len(jobs) > 1 and printer.get("c_combine"):
        pdfname = os.path.join(tmpdir, "ptxprint-{}_{}{}.pdf".format(jobs[0], jobs[-1], prjid))
    else:
        pdfname = os.path.join(tmpdir, "ptxprint-{}{}.pdf".format(jobs[0], prjid))
    # Check the return code to see if generating the PDF was successful before opening the PDF
    if info.res == 0:
        if os.path.exists(pdfname):
            if sys.platform == "win32":
                os.startfile(pdfname)
            elif sys.platform == "linux":
                subprocess.call(('xdg-open', pdfname))
            # Only delete the temp files if the PDF was created AND the user did NOT select to keep them
            if not printer.get("c_keepTemporaryFiles"):
                removeTempFiles(texfiles,tmpdir,info)
    else: # if info.res != 0:
        # it did NOT finish successfully, so help them troubleshoot what went wrong:
        par = par = printer.builder.get_object('ptxprint')
        dialog = Gtk.MessageDialog(parent=par, modal=True, message_type=Gtk.MessageType.ERROR, buttons=Gtk.ButtonsType.OK, \
            text="Error: Unable to create: "+re.sub(r".+[\\/](.+\.pdf)",r"\1",pdfname))
        dialog.format_secondary_text("".join(info.loglines[-20:])+
                                     "----------------------------------------------- \
                                    \nPTXprint version: 0.4.9 (Beta)\
                                    \n----------------------------------------------- \
                                    \nPossible Causes: \
                                    \n  * The USFM text has a syntax error \
                                    \n  * The font file was not installed for ALL users \
                                    \n  * Pictures could be causing it to fail \
                                  \n\nTry using option to 'Hide Advanced Settings' \
                                    \nor check option 'Omit Missing Pictures' \
                                    \n         and then try again...")
        dialog.set_keep_above(True)
        dialog.run()
        dialog.destroy()

def gatherIllustrations(jobs, prjid, prjdir, printer):
    lowRes = printer.get("c_useLowResPics")
    if printer.get("c_useCustomFolder"):
        picdir = printer.customFigFolder
    else:
        picdir = None
    tmpPicpath = os.path.join(printer.working_dir, "tmpPics")
    removeTmpPics(tmpPicpath)
    if not os.path.exists(tmpPicpath):
        os.mkdir(tmpPicpath)
    basenamelist = []
    fullnamelist = []
    fullnamelower = []
    for bk in jobs:
        fname = printer.getBookFilename(bk, prjdir)
        if printer.get("c_usePicList"): # Need to read the PicList to get a list of needed illustrations
            piclstfname = os.path.join(printer.configPath(False), "PicLists", fname)
            doti = piclstfname.rfind(".")
            if doti > 0:
                piclstfname = piclstfname[:doti] + "-draft" + piclstfname[doti:] + ".piclist"
            piclist = []
            if os.path.exists(piclstfname):
                with open(piclstfname, "r", encoding="utf-8") as inf:
                    dat = inf.read()
                    # MAT 19.13 |CN01771C.jpg|col|tr||Bringing the children to Jesus|19:13
                    fullnamelist += re.findall(r"(?i)\|(.+?\.(?=jpg|tif|png|pdf)...)\|", dat)
            fullnamelower = [f.lower() for f in fullnamelist]
        else:
            infname = os.path.join(prjdir, fname)
            with open(infname, "r", encoding="utf-8") as inf:
                dat = inf.read()
                inf.close()
                basenamelist += re.findall(r"(?i)\\fig .*\|([a-z]{2}\d{5})[a-c]?\.(?=jpg|tif|png|pdf)...\|.+?\\fig\*", dat)      # USFM2 AB01234b.ext fig files
                basenamelist += re.findall(r"(?i)\\fig .*\|(.+?(?!\d{5}[a-c]?).+?)\.(?=jpg|tif|png|pdf)...\|.+?\\fig\*", dat)    # USFM2 non-standard fig files
                basenamelist += re.findall(r'(?i)\\fig .+src="([a-z]{2}\d{5})[a-c]?\.(?=jpg|tif|png|pdf)..." .+?\\fig\*', dat)   # USFM3 AB01234b.ext fig files 
                basenamelist += re.findall(r'(?i)\\fig .+src="(.+?(?!\d{5}[a-c]?).+?)\.(?=jpg|tif|png|pdf)..." .+?\\fig\*', dat) # USFM3 non-standard fig files 

    # print("basenamelist:", len(basenamelist), basenamelist)
    # print("fullnamelist:", len(fullnamelist), fullnamelist)
    # print("fullnamelower:", len(fullnamelower), fullnamelower)
    basenamelist = [item.lower() for item in basenamelist]
    srchlist = [picdir]
    for d in ("local", "figures"):
        srchlist += [os.path.join(prjdir, x) for x in (d, d.title())]
    for srchdir in srchlist:
        # print(srchdir)
        if srchdir != None and os.path.exists(srchdir):
            for subdir, dirs, files in os.walk(srchdir):
                if subdir != "tmpPics": # Avoid recursively scanning the folder we are copying to!
                    for file in files:
                        filepath = subdir + os.sep + file
                        shortname = os.path.basename(filepath)
                        shortname = re.sub(r"(?i)\.tif", r".pdf",shortname)
                        if filepath.lower()[-4:] in [".jpg", ".png", ".pdf", ".tif"]:
                            # print(filepath)
                            if printer.get("c_usePicList"):
                                if shortname.lower() in fullnamelist or shortname.lower() in fullnamelower:
                                    if filepath.lower()[-4:] in [".tif"]:
                                        tempPDFname = os.path.join(tmpPicpath, "tempPDF.pdf")
                                        with open(tempPDFname,"wb") as f:
                                            try:
                                                f.write(img2pdf.convert(filepath))
                                            except:
                                                break
                                        if os.path.exists(tempPDFname):
                                            tmpfname = os.path.join(tmpPicpath, shortname)[:-4]+".pdf"
                                            carefulCopy(lowRes, tempPDFname, tmpfname)
                                            os.remove(tempPDFname)
                                    else:
                                        tmpfname = os.path.join(tmpPicpath, shortname)
                                        carefulCopy(lowRes, filepath, tmpfname)

                            else: # processes images found in in-line \fig ... \fig* 
                                origextn = shortname[-4:]
                                basefname = shortname.lower()
                                basefname = re.sub(r"(?i)([a-z][a-z]\d{5})[abc]?\.(jpg|tif|png|pdf)", r"\1",basefname)
                                basefname = re.sub(r"(?i)(.+?)\.(jpg|tif|png|pdf)", r"\1",basefname)  # This should pick up any non-standard filenames
                                if basefname in basenamelist:
                                    if filepath.lower()[-4:] in [".tif"]:
                                        tempPDFname = os.path.join(tmpPicpath, "tempPDF.pdf")
                                        with open(tempPDFname,"wb") as f:
                                            try:
                                                f.write(img2pdf.convert(filepath))
                                            except:
                                                break
                                        if os.path.exists(tempPDFname):
                                            tmpfname = os.path.join(tmpPicpath, basefname)+".pdf"
                                            carefulCopy(lowRes, tempPDFname, tmpfname)
                                            os.remove(tempPDFname)
                                    else: # for .jpg, .png, .pdf
                                        tmpfname = os.path.join(tmpPicpath, basefname+origextn)
                                        carefulCopy(lowRes, filepath, tmpfname)

def carefulCopy(lowRes, srcfile, tgtfile):
    # print("    Src: ", srcfile, "\n    Tgt: ", tgtfile)
    if not os.path.exists(tgtfile):
        copyfile(srcfile, tgtfile)
    else:
        if lowRes: # we want to use the smallest available file
            if os.path.getsize(srcfile) < os.path.getsize(tgtfile):
                copyfile(srcfile, tgtfile)
        else:                                 # we want to use the largest file available
            if os.path.getsize(srcfile) > os.path.getsize(tgtfile):
                copyfile(srcfile, tgtfile)

def removeTempFiles(texfiles,tmpdir,info):
    for extn in ('delayed','parlocs','notepages', 'tex','log'):
        for t in texfiles:
            delfname = os.path.join(tmpdir, t.replace(".tex", "."+extn))
            try:
                os.remove(delfname)
            except OSError:
                dialog = Gtk.MessageDialog(parent=None, modal=True, message_type=Gtk.MessageType.ERROR, buttons=Gtk.ButtonsType.OK,
                    text="Warning: Could not delete temporary file.")
                dialog.format_secondary_text("File: " + delfname)
                dialog.set_keep_above(True)
                dialog.run()
                dialog.destroy()
    for delfname in info['project/books']:
        try:
            os.remove(os.path.join(tmpdir, delfname))
        except OSError:
            dialog = Gtk.MessageDialog(parent=None, modal=True, message_type=Gtk.MessageType.ERROR, buttons=Gtk.ButtonsType.OK,
                text="Warning: Could not delete temporary file.")
            dialog.format_secondary_text("File: " + delfname)
            dialog.set_keep_above(True)
            dialog.run()
            dialog.destroy()
    tmpPicpath = os.path.join(tmpdir, "tmpPics")
    removeTmpPics(tmpPicpath)

def removeTmpPics(path2del):
    # Make sure we're not deleting something closer to Root!
    if len(path2del) > 30 and os.path.exists(path2del):
        try:
            rmtree(path2del) # Preferably remove the previous run's illustrations
        except OSError:
            print("Error Deleting temporary illustrations folder: %s" % (path2del))
        sleep(1)  # wait a second for it to finish deleting

mainw.run(doit)
