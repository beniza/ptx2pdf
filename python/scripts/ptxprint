#!/usr/bin/python3

import argparse, sys, os, subprocess
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk

try:
    import ptxprint
except ImportError:
    sys.path.append(os.path.join(os.path.dirname(__file__), "..", "lib"))
    import ptxprint

parser = argparse.ArgumentParser()
parser.add_argument('pid',nargs="?",help="Project id")
parser.add_argument('-p','--paratext',help="Path to Paratext Projects directory")
parser.add_argument('-d','--directory',default=".",help="Directory to store temporary files in")
parser.add_argument('-m','--macros',help="Directory containing TeX macros (paratext2.tex)")
parser.add_argument('-l','--logging',action="store_true",help="Output logging to terminal instead of logging window")
parser.add_argument('-e','--experimental',action="store_true",help="Enable experimental features")
# parser.add_argument('-t','--test', action='store_true',help="Quick start for a lazy typist")
args = parser.parse_args()

if args.paratext is None:
    args.paratext = ptxprint.runner.pt_settings

if not args.paratext:
    print("No Paratext Settings directory found")
    sys.exit(1)
else:
    args.paratext = args.paratext.replace("\\", "/")
    if args.paratext.endswith("/"):
        args.paratext = args.paratext[:-1]

# Where to find the default for -p
# HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Paratext\8:Settings_Directory
allprojects = []
for d in os.listdir(args.paratext):
    if os.path.exists(os.path.join(args.paratext, d, 'Settings.xml')):
        allprojects.append(d)
allprojects.sort()

mainw = ptxprint.PtxPrinterDialog(allprojects, args.paratext, working_dir=args.directory)
mainw.ExperimentalFeatures(args.experimental)

if args.pid:
    mainw.set("cb_project", args.pid)

def dojob(jobs, info, prjid, prjdir, tmpdir, logbuffer=None):
    donebooks = []
    for b in jobs:
        out = info.convertBook(b, tmpdir, prjdir)
        donebooks.append(out)
    info["project/books"] = donebooks
    if len(jobs) > 1:
        outfname = "ptxprint-{}_{}{}.tex".format(jobs[0], jobs[-1], prjid)
    else:
        outfname = "ptxprint-{}{}.tex".format(jobs[0], prjid)
    info.update()
    with open(os.path.join(tmpdir, outfname), "w", encoding="utf-8") as texf:
        texf.write(info.asTex(filedir=tmpdir))
    os.putenv("hyph_size", "32749")     # always run with maximum hyphenated words size (xetex is still tiny ~200MB resident)
    ptxmacrospath = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../src"))
    if not os.path.exists(ptxmacrospath):
        for b in (getattr(sys, 'USER_BASE', '.'), sys.prefix):
            if b is None:
                continue
            ptxmacrospath = os.path.abspath(os.path.join(b, 'ptx2pdf'))
            if os.path.exists(ptxmacrospath):
                break
    if info['project/useptmacros'] == "false":
        if not os.getenv('TEXINPUTS'):
            texinputs = [os.path.abspath(tmpdir), ptxmacrospath]
            os.putenv('TEXINPUTS', (";" if sys.platform=="win32" else ":").join(texinputs))
    elif sys.platform == "linux":
        if not os.getenv('TEXINPUTS'):
            mdirs = args.macros or "/usr/lib/Paratext8/xetex/share/texmf-dist/tex/ptx2pdf:/usr/lib/Paratext9/xetex/share/texmf-dist/tex/ptx2pdf"
            os.putenv('TEXINPUTS', ".:" + mdirs)
    os.putenv("MISCFONTS", ptxmacrospath)
    runner = ptxprint.runner.call(["xetex", "--halt-on-error", outfname], cwd=tmpdir, logbuffer=(logbuffer if not args.logging else None))
    delayed = outfname.replace(".tex", ".delayed")
    if os.path.exists(delayed):
        if isinstance(runner, subprocess.Popen) and runner is not None:
            runner.wait(200)
            res = runner.returncode
        else:
            res = runner
        if res == 0:
            runner = ptxprint.runner.call(["xetex", "--halt-on-error", outfname], cwd=tmpdir, logbuffer=(logbuffer if not args.logging else None))
    if logbuffer is not None:
        if isinstance(runner, subprocess.Popen) and runner is not None:
            runner.wait(200)
            res = runner.returncode
        else:
            res = runner
        # logbuffer.bind_subprocess(None)
    print("cd {}; xetex {} -> {}".format(tmpdir, outfname, res))
    if res != 0:
        print('\a') # play a sound to say that it did NOT finish successfully.
    return outfname

def doit(printer):
    info = printer.info or ptxprint.Info(printer, args.paratext, printer.prjid)
    prjid = printer.get("cb_project")
    prjdir = os.path.join(args.paratext, prjid)
    if prjid is None or not len(prjid):     # can't print no project
        return
    # save config
    info.update()
    info.GenerateNestedStyles()
    config = info.createConfig(printer)
    with open(os.path.join(prjdir, "ptxprint.cfg"), "w", encoding="utf-8") as outf:
        config.write(outf)
    tmpdir = os.path.join(prjdir, 'PrintDraft') if printer.get("c_useprintdraftfolder") else args.directory
    if not os.path.exists(tmpdir):
        os.makedirs(tmpdir)
    jobs = printer.getBooks()
    if printer.get("c_combine"):
        texfiles = [dojob(jobs, info, prjid, prjdir, tmpdir, logbuffer=printer.logbuffer)]
    else:
        texfiles = [dojob([j], info, prjid, prjdir, tmpdir, logbuffer=printer.logbuffer) for j in jobs]
    # Open the resulting PDF if it exists
    if len(jobs) > 1:
        pdfname = os.path.join(tmpdir, "ptxprint-{}_{}{}.pdf".format(jobs[0], jobs[-1], prjid))
    else:
        pdfname = os.path.join(tmpdir, "ptxprint-{}{}.pdf".format(jobs[0], prjid))
        
    # Need to check the return code to see if generating the PDF was successful. And if not, then issue some 
    # warning or error message rather than leave the PREVIOUS PDF open and pretend that everything worked fine! :-(
    if os.path.exists(pdfname):
        if sys.platform == "win32":
            os.startfile(pdfname)
        elif sys.platform == "linux":
            subprocess.call(('xdg-open', pdfname))
        # Only delete the temp files if the PDF was creates AND the user did NOT select to keep them
        if not printer.get("c_keepTemporaryFiles"):
            removeTempFiles(texfiles,tmpdir,info)

def removeTempFiles(texfiles,tmpdir,info):
    for extn in ('delayed','parlocs','notepages', 'tex','log'):
        for t in texfiles:
            delfname = os.path.join(tmpdir, t.replace(".tex", "."+extn))
            try:
                os.remove(delfname)
            except OSError:
                dialog = Gtk.MessageDialog(None, Gtk.DialogFlags.MODAL, Gtk.MessageType.ERROR, Gtk.ButtonsType.OK,
                    "Warning: Could not delete temporary file.")
                dialog.format_secondary_text("File: " + delfname)
                dialog.run()
                dialog.destroy()
    for delfname in info['project/books']:
        try:
            os.remove(os.path.join(tmpdir, delfname))
        except OSError:
            dialog = Gtk.MessageDialog(None, Gtk.DialogFlags.MODAL, Gtk.MessageType.ERROR, Gtk.ButtonsType.OK,
                "Warning: Could not delete temporary file.")
            dialog.format_secondary_text("File: " + delfname)
            dialog.run()
            dialog.destroy()
        
mainw.run(doit)
